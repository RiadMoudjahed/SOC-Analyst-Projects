# SQL Injection Prevention Demo
_A compact educational lab that demonstrates how SQL injection (SQLi) works and how to prevent it using parameterized queries, bcrypt authentication, and audit logging._

---

## Table of contents
- [What is SQL injection?](#what-is-sql-injection)
- [Lab objectives](#lab-objectives)
- [Environment & prerequisites](#environment--prerequisites)
- [Step 1 — Create schema and sample data](#step-1---create-schema-and-sample-data)
- [Step 2 — Vulnerable demo (local only)](#step-2---vulnerable-demo-local-only)
- [Step 3 — Secure implementation](#step-3---secure-implementation)
- [Step 4 — Audit logging and RBAC demo](#step-4---audit-logging-and-rbac-demo)
- [Evidence to collect (for portfolio)](#evidence-to-collect-for-portfolio)
- [Security & safety notes](#security--safety-notes)
- [What I learned](#what-i-learned-example-reflection)
- [Attribution](#attribution)

---

## What is SQL injection?
See the excellent PortSwigger writeup: [What is SQL injection?](https://portswigger.net/web-security/sql-injection)

> SQL injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. This can expose or modify data the application can access.

<img width="600" height="460" alt="image" src="https://github.com/user-attachments/assets/d7b7d86b-d716-4c75-bf66-9a07f4787e05" />

---

## Lab objectives
- Demonstrate a **vulnerable** login implementation (local-only demonstration).  
- Show how **SQLi** can bypass naive authentication.  
- Implement a **secure** login using parameterized queries and bcrypt.  
- Add simple **audit logging** for failed/successful login attempts.  
- Produce reproducible artifacts for a portfolio: `SQLi-Test.sql`, screenshots, and a short write-up.

---

## Environment & prerequisites
- Python 3.8+  
- SQLite (built-in with Python) or DB Browser for SQLite (optional GUI)

---

## Step 1 — Create schema and sample data

### 1. Create the users Table:

```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,
  role TEXT
);

INSERT INTO users (username, password_hash, role) VALUES
('alice', '$2y$10$8E0Kq1clJM64N2w1H2i9d.6srB0pK0cFludEXVaZLDiL5ZuDrIVFi', 'admin'),
('crane', '$2y$14$LyAgPLXany8Z0nf7V3PsIeG.MOVW5CqJ2Lb1NCOKZh/Q.FVc0bOpa', 'manager'),
('bob',   '$2y$10$GClhnEim64YM8bjLIdSMJ.SxzKBiEzMbTXKWyNfM4duB2.CBAHHEO', 'user');
```

### 2. Create the transactions table:

```sql
CREATE TABLE transactions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  amount REAL NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  description TEXT,
  FOREIGN KEY(user_id) REFERENCES users(id)
);

INSERT OR IGNORE INTO transactions ( user_id, amount, description) VALUES
(1, 1200.50, 'Salary Deposit'),
(3, -45.99, 'Online Purchase');
```

### 3. Create the audit logs table:

```sql
CREATE TABLE audit_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  action TEXT,
  detail TEXT,
  ip_address TEXT,
  create_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

<p align="center">
  <img width="480" alt="Create users table" src="https://github.com/user-attachments/assets/ff709c1f-31dc-4ab4-9cac-0e461ecd2534" />
</p>
<p align="center">
  <img width="320" alt="Create transactions table" src="https://github.com/user-attachments/assets/f306561b-1f5a-4980-af13-1441c00a01e4" />
  <img width="320" alt="Create audit logs table" src="https://github.com/user-attachments/assets/b2ecad9a-dbfa-4cfa-b753-7486acf859f5" />
</p>

<p align="center"><em>Figure 1 — Users table (top) and related transaction/audit tables (bottom).</em></p>

---

## Step 2 — Vulnerable demo (local only)

```python
# vulnerable_login.py

import sqlite3    # Import sqlite3 library

conn = sqlite3.connect('SQLi-Test.db')    # Connect to the database
cur = conn.cursor()    # Open connection

username = input("username> ")    # Ask the user to enter a username
password = input("password> ")    # Ask the user to enter a password

# Vulnerable: concatenation -> subject to injection if used in WHERE conditions
query = f"SELECT id, username, password_hash, role FROM users WHERE username = '{username}';"
print("Executing query:", query)
cur.execute(query)
row = cur.fetchone()
print("DB returned:", row)

conn.close()    # Close connection
```
### Test the code using the following payload:
```
' OR '1'='1
```

<img width="934" height="824" alt="4  write python code for vulnerability test and RUN" src="https://github.com/user-attachments/assets/16311018-f9a1-476b-9d7c-d93b5c8c02d0" />

---

## Step 3 — Secure implementation

### Before we get started, [What is 'bcrypt'?](https://nordvpn.com/blog/what-is-bcrypt/)

Bcrypt is a lauded **password-storing** solution that uses **complicated cryptographic algorithms**, significantly reducing the chances of a hacker cracking your password. 

```python
# secure_login.py

### THIS CODE WAS MADE BY ChatGPT AI

import sqlite3                    # stdlib DB-API for SQLite — used to open the database and run SQL.
import bcrypt                     # bcrypt library for verifying password hashes securely.
from pathlib import Path          # Path helper for filesystem paths (more robust than plain strings).

DB_PATH = Path("SQLi-Test.db")          # Path to the SQLite database file used by this lab.

def normalize_hash(stored):
    # Some bcrypt hashes created by other languages (e.g., PHP) use the $2y$ prefix.
    # Python's bcrypt expects $2b$ (or accepts $2a$/2b). This function converts $2y$ -> $2b$
    # so checkpw() can correctly parse and verify the hash in this educational/demo context.
    if stored.startswith("$2y$"):
        return "$2b$" + stored[4:]  # replace leading $2y$ with $2b$, keep the rest of the hash
    return stored                   # otherwise return the hash unchanged

def log_audit(cur, user_id, action, detail, ip='127.0.0.1'):
    # Insert a new audit record into the audit_logs table.
    # Uses a parameterized query (placeholders) to avoid SQL injection in the logging step.
    cur.execute(
        "INSERT INTO audit_logs (user_id, action, detail, ip_address) VALUES (?, ?, ?, ?)",
        (user_id, action, detail, ip)
    )

def main():
    # Open a connection to the SQLite database. Provides a Connection object.
    conn = sqlite3.connect(str(DB_PATH))

    # Create a cursor from the connection — the cursor is what we use to execute SQL commands.
    cur = conn.cursor()

    # Read username from user input and strip whitespace (defensive: remove accidental leading/trailing spaces).
    username = input("username> ").strip()

    # Read password from user input and convert to bytes — bcrypt expects bytes for checkpw().
    password = input("password> ").encode('utf-8')

    # Parameterized query (safe): fetch the user row by username.
    # The '?' placeholder and tuple parameter prevent user input from altering query structure (prevents SQLi).
    cur.execute("SELECT id, username, password_hash, role FROM users WHERE username = ?", (username,))
    row = cur.fetchone()   # Fetch the first (and expectedly only) matching row; returns None if no match.

    if not row:
        # No user with that username — print a generic error and log the failed attempt with no user_id.
        # Note: generic message avoids username enumeration in a real app.
        print("Invalid credentials")
        log_audit(cur, None, 'failed_login', f'username={username}')
    else:
        # Unpack the returned row into variables for clarity.
        user_id, user, pw_hash, role = row

        # Normalize hash prefix if necessary and convert to bytes for bcrypt.
        pw_hash = normalize_hash(pw_hash).encode('utf-8')

        try:
            # bcrypt.checkpw compares the provided password (bytes) with the stored bcrypt hash (bytes).
            # Returns True if match; False otherwise.
            if bcrypt.checkpw(password, pw_hash):
                # Successful authentication — print success and log it.
                print(f"Authenticated: {user} (role: {role})")
                log_audit(cur, user_id, 'successful_login', f'username={username}')
            else:
                # Password did not match — generic failure message and audit log (with user_id for investigation).
                print("Invalid credentials")
                log_audit(cur, user_id, 'failed_login', f'username={username}')
        except ValueError:
            # bcrypt.checkpw can raise ValueError if the stored hash is malformed or unsupported.
            # We catch it to avoid crashing and to log an authentication error for later review.
            print("Authentication error (hash).")
            log_audit(cur, user_id, 'auth_error', f'username={username}')

    # Persist any new audit log rows (or other changes) to the DB.
    conn.commit()

    # Close the database connection to release resources.
    conn.close()

# Standard Python idiom: run main() only if the script is executed directly (not when imported).
if __name__ == "__main__":
    main()
```

<img width="1167" height="952" alt="5" src="https://github.com/user-attachments/assets/768f089c-c3a7-403e-933e-94491a2a17cd" />


As you can see, after we emplimented the bcrypt hash fumction the Injection payload didn't work and our database became more secured.
